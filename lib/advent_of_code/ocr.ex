defmodule AdventOfCode.OCR do
  @letters_6x4 %{
    ".##.\n#..#\n#..#\n####\n#..#\n#..#" => "A",
    "###.\n#..#\n###.\n#..#\n#..#\n###." => "B",
    ".##.\n#..#\n#...\n#...\n#..#\n.##." => "C",
    "####\n#...\n###.\n#...\n#...\n####" => "E",
    "####\n#...\n###.\n#...\n#...\n#..." => "F",
    ".##.\n#..#\n#...\n#.##\n#..#\n.###" => "G",
    "#..#\n#..#\n####\n#..#\n#..#\n#..#" => "H",
    ".###\n..#.\n..#.\n..#.\n..#.\n.###" => "I",
    "..##\n...#\n...#\n...#\n#..#\n.##." => "J",
    "#..#\n#.#.\n##..\n#.#.\n#.#.\n#..#" => "K",
    "#...\n#...\n#...\n#...\n#...\n####" => "L",
    ".##.\n#..#\n#..#\n#..#\n#..#\n.##." => "O",
    "###.\n#..#\n#..#\n###.\n#...\n#..." => "P",
    "###.\n#..#\n#..#\n###.\n#.#.\n#..#" => "R",
    ".###\n#...\n#...\n.##.\n...#\n###." => "S",
    "#..#\n#..#\n#..#\n#..#\n#..#\n.##." => "U",
    "#...\n#...\n.#.#\n..#.\n..#.\n..#." => "Y",
    "####\n...#\n..#.\n.#..\n#...\n####" => "Z"
  }

  @letters_10x6 %{
    "..##..\n.#..#.\n#....#\n#....#\n#....#\n######\n#....#\n#....#\n#....#\n#....#" => "A",
    "#####.\n#....#\n#....#\n#....#\n#####.\n#....#\n#....#\n#....#\n#....#\n#####." => "B",
    ".####.\n#....#\n#.....\n#.....\n#.....\n#.....\n#.....\n#.....\n#....#\n.####." => "C",
    "######\n#.....\n#.....\n#.....\n#####.\n#.....\n#.....\n#.....\n#.....\n######" => "E",
    "######\n#.....\n#.....\n#.....\n#####.\n#.....\n#.....\n#.....\n#.....\n#....." => "F",
    ".####.\n#....#\n#.....\n#.....\n#.....\n#..###\n#....#\n#....#\n#...##\n.###.#" => "G",
    "#....#\n#....#\n#....#\n#....#\n######\n#....#\n#....#\n#....#\n#....#\n#....#" => "H",
    "...###\n....#.\n....#.\n....#.\n....#.\n....#.\n....#.\n#...#.\n#...#.\n.###.." => "J",
    "#....#\n#...#.\n#..#..\n#.#...\n##....\n##....\n#.#...\n#..#..\n#...#.\n#....#" => "K",
    "#.....\n#.....\n#.....\n#.....\n#.....\n#.....\n#.....\n#.....\n#.....\n######" => "L",
    "#....#\n##...#\n##...#\n#.#..#\n#.#..#\n#..#.#\n#..#.#\n#...##\n#...##\n#....#" => "N",
    "#####.\n#....#\n#....#\n#....#\n#####.\n#.....\n#.....\n#.....\n#.....\n#....." => "P",
    "#####.\n#....#\n#....#\n#....#\n#####.\n#..#..\n#...#.\n#...#.\n#....#\n#....#" => "R",
    "#....#\n#....#\n.#..#.\n.#..#.\n..##..\n..##..\n.#..#.\n.#..#.\n#....#\n#....#" => "X",
    "######\n.....#\n.....#\n....#.\n...#..\n..#...\n.#....\n#.....\n#.....\n######" => "Z"
  }

  def letters_6x4(), do: @letters_6x4
  def letters_10x6(), do: @letters_10x6

  defp lookup_letter(letter, letter_width) do
    case letter_width do
      4 -> Map.get(@letters_6x4, letter)
      6 -> Map.get(@letters_10x6, letter)
    end
  end

  defp row_letter_parts(row, letter_width) do
    row
    |> String.codepoints()
    |> Enum.chunk_every(letter_width + 1)
    |> Enum.map(fn letter ->
      letter
      |> to_string()
      |> String.slice(0..(letter_width - 1))
    end)
  end

  def read_screen(screen, letter_width \\ 4) do
    screen
    |> Enum.map(&row_letter_parts(&1, letter_width))
    |> Enum.zip()
    |> Enum.map(fn letter_parts ->
      letter_parts
      |> Tuple.to_list()
      |> Enum.join("\n")
      |> lookup_letter(letter_width)
    end)
    |> to_string()
  end
end
